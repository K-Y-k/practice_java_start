# :rocket: 자바 입문
자바 기본기를 확실히 다지기 위한 공부로 

핵심 내용과 내가 잘 숙지하지 못했던 부분 위주로 정리 (2023.12.21 ~ 2023.12.26)

# :page_facing_up: 목차
- <a href="#0"> 객체 지향 프로그래밍이 중요한 이유 </a> 
- <a href="#1"> 자바란? </a> 
- <a href="#2"> 컴파일과 실행 </a>
- <a href="#3"> 자바 메모리 구조 </a>
- <a href="#4"> 변수 </a>
- <a href="#5"> 패키지 </a>
- <a href="#6"> for vs while </a> 
- <a href="#7"> 스코프 </a> 
- <a href="#8"> 형변환, 오버플로우 </a>
- <a href="#9"> 배열 </a> 


## <b id="0"> 객체 지향 프로그래밍이 중요한 이유</b>
- 대규모 소프트웨어는 **코드 재사용성, 모듈화, 확장성과 유연성, 추상화를 통한 복잡도 관리, 유지보수 등이 중요한데 객체 지향 프로그래밍이 이 이점들을 제공해주기 때문**이다.
- 객체지향 언어인 **자바는 캡슐화, 상속, 추상화, 다형성 같은 객체지향 개념을 이용**한다.


## <b id="1"> 자바란? </b>
- **객체 지향 프로그래밍 언어**이다.
- 특징은 **객체 지향적**이고 **가비지 컬렉션으로 메모리를 자동으로 관리**해주고 **멀티 스레드를 지원**한다.
- 자바는 **표준 스펙과 구현**으로 나눌 수 있다.
  - 자바 표준 스펙
    - **자바는 이렇게 만들어야 한다는 설계도**이며 **문서**이다.
    - **이 표준 스펙을 기반으로 실 작동하는 자바를 개발**한다.
    - 자바 표준 스펙은 자바 커뮤니티 프로세스(JCP)를 통해 관리된다.
  - 다양한 자바 구현
    - **여러 회사에서 자바 표준 스펙에 맞추어 작동하는 자바를 개발**한다.
    - **각 표준 스펙의 장단점**이 있다. ex) Amazon Correto는 AWS에 최적화
    - 각 표준 스펙 회사들은 대부분 윈도우, MAC, 리눅스 같이 **다양한 OS에서 작동하는 버전의 자바도 함께 제공**한다.
    - 각 회사의 표준 스펙들은 **모두 표준 스펙에 맞도록 개발했으므로 다른 표준 스펙으로 변경해도 자바 구현에 문제없이 동작**한다.
- **운영체제의 독립성**
  - 일반적인 프로그램은 각 OS의 명령어들로 구성되어 있기에 호환문제로 다른 운영체제에서 실행할 수 없지만
  - 자바 프로그램은 각 OS의 자바가 모두 있기에 **자바가 설치된 모든 OS에서 실행**할 수 있다.


## <b id="2"> 컴파일과 실행 </b>
- 자바 프로그램은 컴파일과 실행 단계를 거치는데
    1. **소스 코드를 작성**한다.
    2. 작성된 소스 코드를 **javac라는 자바 컴파일러를 사용**해서

       **.java 파일에서 .class 파일로 생성한 후**

       **자바 소스 코드를 바이트코드로 변환하며**

       **자바 가상 머신에서의 최적화 및 문법 오류를 검출하는 컴파일을 진행**한다.
    3. **자바 가상머신(JVM)이 실행되면서 자바 프로그램이 작동**한다.

- 원래 이렇게 javac로 해야하지만 (intelliJ 같은) **IDE가 자동으로 처리**해준다.

  intelliJ 의 out 폴더를 보면 컴파일된 .class 파일이 있는 것을 확인할 수 있다.


## <b id="3"> 자바 메모리 구조 </b>
<img src="https://github.com/K-Y-k/practice_java_basic/assets/102020649/84b78324-6646-4ef5-9f32-0506e2fc5643.gif" width="60%"/>

- 크게 **메서드 영역, 스택 영역, 힙 영역 3개**로 나눌 수 있다.
  - 메서드 영역
    - 프로그램을 **실행하는데 필요한 공통 데이터를 관리**한다.
    - 클래스 정보(공통된 메서드를 사용하기 위한 정보들), static 영역, 상수 풀로 존재하고 이 영역은 프로그램의 **모든 영역에서 공유**한다.
    
  - 스택 영역
    - **실제 프로그램이 실행되는 영역**이다.
    - 메서드를 **실행할 때마다 스택 프레임이 하나씩 쌓이고** 메서드가 **종료되면 해당 스택 프레임이 제거**된다. 
    - **스택 영역은 쓰레드 수 만큼 생성**된다.
        
  - 힙 영역
    - **객체(인스턴스)와 배열이 생성되는 영역**이다.
    - **new 명령어를 사용하면 이 영역을 사용**하는 것이다.
    - 메서드 영역의 종료 등으로 인스턴스가 **참조하는 곳이 없어지면 GC가 자동으로 제거**해준다.
        
    
  - 힙 영역인 인스턴스에서의 메서드를 호출하면?

    → 메서드 영역에 있는 코드를 불러서 수행한다!
    - 인스턴스 생성하면 필요한 필드 값들은 모두 다르기에 힙 영역에 존재하지만,

      메서드들은 공통된 코드이기에 공유하도록 메서드 영역이 따로 존재하는 것이다!


## <b id="4"> 변수 </b>
- **변할 수 있는 수**로 값이 능동적으로 **변경될 때 이러한 값의 데이터를 보관하는 저장소**이다.
- **변수를 선언하면** 컴퓨터의 **메모리 공간을 확보해서 그곳에 데이터를 저장**할 수 있다.
- **변수의 이름을 통해**서 해당 **메모리 공간에 접근**할 수 있다.
- 즉, **데이터를 보관할 수 있는 공간을 만들고 그곳에 접근할 수 있는 이름을 부여한 것**이다.


- 변수의 종류
  - **멤버 변수**(필드) : 클래스에 선언
     - **인스턴스 변수**                    : static이 붙지 않는 멤버 변수
     - **클래스/정적/static 변수**     : static이 붙은 멤버 변수 (공용 사용할 때)
  - **지역 변수**          : 메서드에 선언, 매개변수도 지역 변수의 한 종류


- 변수 초기화
  - **변수를 선언하고**, 선언한 변수에 **처음으로 값을 저장**하는 것
  - **멤버 변수는 자동으로 초기화** 해준다.
  - **지역변수는 항상 직접 초기화** 해야 한다.
        
        ```
        // ex) 멤버 변수 초기화
        public class InitData {
            int value1;      // 초기화 하지 않음
            int value2 = 10; // 10으로 직접 초기화
        }
        
        public static void main(String[] args) {
            InitData data = new InitData();
            System.out.println("data.value1 = " + data.value1); // 자동 초기화한 0이 나옴
            System.out.println("data.value2 = " + data.value2); // 초기화 되어있던 10이 나옴
        }
        ```
        

- 타입
  - 변수는 **데이터를 다루는 종류에 따라 다양한 형식**이 있는데 이걸 타입이라고 한다.
  - ex) int, double, boolean, char, String


- 리터럴
  - **직접 적어서 고정한 값**을 뜻한다.
  - ex) int a = 100; 에서 **100이 정수 리터럴**


- 변수명 관례 - 낙타 표기법
  - **변수, 함수, 클래스 등의 이름을 지을 때 많이 사용**하는 표기법이다.
  - 이름이 **여러 단어로 구성되어 있을 때, 각 단어의 첫 글자가 대문자로 시작**하게한다.
  - 변수 **이름은 용도에 맞게 명확하게 지어야한다**.


## <b id="5"> 패키지 </b>
- 매우 많은 클래스가 등장하면서

  **관련 있는 클래스들을 분류해서 구분 및 관리하기 위해 나온 폴더**이다.
    
- import
  - **다른 패키지의 클래스를 가져올 때 필요한 경로를 지정**하여 클래스를 사용할 때 패키지 명을 생략할 수 있다.
  - **다른 패키지의 같은 클래스명들을 사용할 경우**는

    하나만 import가 가능하고 다른 하나는 경로까지 같이 작성해야 하므로 **자주 사용하는 것을 import**한다.

- 패키지 규칙
    
    <img src="https://github.com/K-Y-k/practice_java_basic/assets/102020649/f6069acc-31bc-47eb-a67c-441c79bc7808.gif" width="30%"/>
    
    - **패키지의 이름과 위치는 폴더(디렉토리) 위치와 같아야 한다**. (필수)
    - 이름은 모두 **소문자** (관례)
    - 앞 부분에는 일반적으로 **회사의 도메인 이름을 거꾸로 사용**한다. (관례)
      - ex) com.회사명.어플리케이션명 → 큰거에서 작은거로 세분화
      - **외부 라이브러리와 함께 사용하면 패키지 명이 겹칠 수 있기에 이렇게 사용하면 절대 겹치지 않는다**.


## <b id="6"> for vs while </b>
- for문은 **한 줄에 구조화**가 담겨있어 **코드 이해가 쉽다**.
- **반복횟수가 정해진 경우는 for문**을 사용하는 것이 **구조적으로 더 깔끔하고 유지보수** 하기 좋다.
- while문은 **조건에 따른 반복**으로 **종료시점을 정확히 알 수 없을 때 사용**한다.
- 향상된 for문(for-each문)은 **배열 또는 컬렉션의 인덱스는 사용하지 않고 요소만 모두 순회할 때 사용**한다.


## <b id="7"> 스코프 </b>
```
public class Scope3_2 {
    public static void main(String[] args) {
        int m = 10;  // 지역 변수 m 생존 시작

        if (m > 0) {
            int temp = m * 2; // 스코프 범위를 필요한 범위에 맞게 잘 활용해야 효율적입니다.
                              // 지역 변수 temp 생존 시작
						System.out.println("temp = " + temp);
        }  // temp 생존 종료

        System.out.println("m = " + m);
    }
}                   // m 생존 종료
```
- 스코프는 **존재할 수 있는 범위를 나타낸다**.
- 변수는 선언한 위치에 따라 **지역 변수, 멤버 변수(클래스 변수, 인스턴스 변수)로 분류**한다.
- 스코프가 **존재하는 이유**는 **메모리 낭비가 일어나지 않게** 하고 **코드 복잡성의 증가를 방지하여 유지보수 관점**에서도 좋다.
- 그렇기 때문에 **스코프 범위를 필요한 범위에 맞게 사용해야 효율적**이다.
- **좋은 프로그램은** 무한한 자유가 있는 프로그램이 아니라 **적절한 제약이 있는 프로그램**이다. (제약의 예시가 타입이다.)


## <b id="8"> 형변환, 오버플로우 </b>
- 작은 범위의 타입 → 큰 범위 타입으로 변환할 때는
    
  **자동 형변환**이 가능하다.
    
- 큰 범위의 타입 → 작은 범위의 타입으로 변환할 때는
    
  **(타입명)을 적어주는 명시적 형변환을 사용해야 한다**. 
    
- 작은 범위의 타입으로 변환하면서
    
  **현재 값이** **데이터 형식의 범위를 벗어나게 될 경우 오버플로우가 발생**한다.
    

- 형변환은 **계산하면서 자동 형변환이 발생**할 수 있다.
    1. **같은 타입끼리의 계산은 같은 타입의 결과**를 낸다.
    2. **서로 다른 타입의 계산은 더 큰 범위로 자동 형변환**이 일어난다.


## <b id="9"> 배열 </b>
- **같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것**이다.
- 배열을 **생성하면 메모리에 이 배열에 접근할 수 있는 참조값(주소)을 반환하고**
    
  **이 참조값을 변수에 보관**한다.
- 배열은 **같은 타입의 변수를 반복해서 선언하고 사용하는 문제를 해결**해주고

  사이즈 내의 개수로 선언하면 **사용한 크기만큼만 동적으로 맞춰주는 장점**이 있지만, 
    
  **사이즈를 지정한 후에는 늘릴 수 없는 단점**이 있다.
